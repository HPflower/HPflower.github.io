---
title: STM32定时器中断及串口中断发送数据
date: 2024-7-6 2:19:00 +0800
categories: [Blog,STM32]
tags: [STM32,HAL库]
---

# 前言
在做一个小项目时遇到的一些问题，记录下过程。项目本身很简单，使用水位传感器去读取水位并通过串口输出，但是串口输出的数据与预期数据不匹配。


# 内容
天呐...这么简单的任务...我随手在网上抄了下相关代码  

ADC获取湿度值实现：
```
uint16_t GetHumidity(int times)
{
  uint16_t data = 0;
  uint32_t H_all = 0;
  float H_arg = 0;
  uint8_t t;

  // 进行多次ADC转换并累加
  for (t = 0; t < times; t++) {
    H_all += HAL_ADC_GetValue(&hadc1);
    HAL_Delay(1); // 延时1毫秒
  }
  // 计算平均值
  H_arg = (H_all / times);
  //printf("%0.2f\r\n",H_arg);
  // 根据转换公式计算湿度值
  data = (4022 - H_arg) / 2411 * 100;
  // 确保湿度值在合理范围内（0~100）
  if(data > 100){
    data = 100;
  }
  return data;
}
```

while 循环中的代码：
```
  while (1)
  {
    uint8_t DATA[4] = {0XAA,0XAF,0X00,0XFF};
    HAL_ADC_Start(&hadc1);     //启动ADC转换
    HAL_ADC_PollForConversion(&hadc1, 50);   //等待转换完成，50为最大等待时间，单位为ms
    DATA[2] = GetHumidity(10);
    HAL_UART_Transmit_IT(&huart1,DATA,sizeof(DATA));
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
```

烧录上电一跑，欸嘿，成哩）  
![Pic1](/assets/Posts_Pic/STM32Note1_Pic1.png)  

正当我心想又能摆烂一下午的时候，又有新活了：定时读取湿度值并串口中断发送...  
似乎是个很人畜无害的需求呐...那就浅浅花个几分钟秒掉吧~（当时的想法）  

好的...时钟频率72Mhz...预分频系数...巴拉巴拉一填，代码一挪：
```
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){
	uint8_t DATA[4] = {0XAA,0XAF,0X00,0XFF};
	if(htim == &htim6){
		HAL_ADC_Start(&hadc1);     //启动ADC转换
		HAL_ADC_PollForConversion(&hadc1, 50);   //等待转换完成，50为最大等待时间，单位为ms
		DATA[2] = GetHumidity(10);
		HAL_UART_Transmit_IT(&huart1,DATA,sizeof(DATA));
	}
}
```

这不就好了嘛...但当我编译烧录一看，发现了问题：  
![Pic2](/assets/Posts_Pic/STM32Note1_Pic2.png)  

QAQ不是，我数据呐！怎么就剩一个帧头啦？？数据发送是正常的...在main主循环里跑也是正常的...难道和定时器的中断有关？我连忙试着换了一个串口发送函数：[HAL_UART_Transmit] 这下数据正常了...  

![Pic3](/assets/Posts_Pic/STM32Note1_Pic3.png)  

但是我不舒服呐... 居然被一个小bug逼着改用了一个函数...我倒要看看为什么[HAL_UART_Transmit_IT]用不了（
于是乎便开始了痛苦的调试之旅qwq  
定时器启用中断...while...中断回调函数...串口中断函数统统打上断点！
调试一跑，发现了一丝端倪：  
![Pic4](/assets/Posts_Pic/STM32Note1_Pic4.png)  

嗯嗯嗯？串口状态繁忙？这说明什么呐？这说明串口上一次的数据都还没有发完，就又要准备发送这次的数据啦！
考虑到使用[HAL_UART_Transmit]函数能够正常发送，这也能说得通了（HAL_UART_Transmit为阻塞发送，串口数据发完才会继续执行后续代码）
那怎么办？等[HAL_UART_Transmit_IT]发送完再继续发送不就好了？堵住一个定时器总比整个程序堵在那边好吧（被打）  

于是便理所当然的在定时器回调中使用了[HAL_TIM_Base_Stop_IT]来关闭定时器的中断功能,并复用了[HAL_UART_TxCpltCallback]函数来重新启动定时器的中断功能相关实现如下:  
![Pic5](/assets/Posts_Pic/STM32Note1_Pic5.png)  

跑了一下，问题解决....了？不对，第一帧数据怎么还是AA 00 00 00 ？？？  
![Pic6](/assets/Posts_Pic/STM32Note1_Pic6.png)  

这个问题网上似乎挺多人遇到的，随便找的一点资料：
    因为TIM_TimeBaseInit会导致update事件。如果这个时候中断是使能的就会立即进入中断。
这是TIM_TimeBaseInit函数最后一条语句
/* Generate an update event to reload the Prescaler
and the repetition counter(only for TIM1 and TIM8) value immediately */
TIMx->EGR = TIM_PSCReloadMode_Immediate;

解决方法也附上：在[HAL_TIM_Base_Start_IT] 函数前加上[__HAL_TIM_CLEAR_FLAG(&htim6,TIM_FLAG_UPDATE);] 来清除标志位就好了。  
![Pic7](/assets/Posts_Pic/STM32Note1_Pic7.png)  

最终效果：（可能还有点小问题，以后再处理吧...）  
![Pic8](/assets/Posts_Pic/STM32Note1_Pic8.png)  
